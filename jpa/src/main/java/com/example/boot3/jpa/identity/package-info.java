/**
 * JPA主键生成策略
 * <p>
 *     主键数据的生成主要时基于 @Id 注解定义的，
 *     而在实际开发中，数据库表结构的设计是有所不同的，JPA为了适应这些不同数据库表的定义，也提供有不同的主键生成策略。
 * <p>
 *     五种主键生成策略 {@link jakarta.persistence.GenerationType}
 *     AUTO
 *          默认选项，由JPA选择合适的主键生成策略
 *     IDENTITY
 *          采用数据库ID自增长的方式来自增主键字段，Oracle不支持
 *     SEQUENCE
 *          采用序列的方式来自增主键，主要应用于Oracle数据库
 *     UUID
 *          采用UUID字符串的形式来自增主键
 *     TABLE
 *          通过指定的数据库表生成主键，该策略用于数据库移植 {@link com.example.boot3.jpa.po.DeptPO}
 * <p>
 *     使用TABLE来管理主键生成的缺陷
 *          虽然在JPA中提供了该支持，但是从正常的开发角度来讲，这样的管理实在是过于繁琐了。
 *          毕竟在进行主键数据修改的时候需要进行数据锁定处理（行锁），
 *          如果运行在高并发的场景下，结果是惨烈的，毕竟请求一多，响应的时间一长，问题就来了。
 *          如果要想要真正的实现这种分布式的ID管理，则最佳的做法是引入缓存数据库进行处理，
 *          即：通过代码生成一系列的主键，而后在每次用到的时候获取到这些主键进行处理。（分布式主键生成器）
 *
 * @author caimeng
 * @date 2024/6/7 14:19
 */
package com.example.boot3.jpa.identity;