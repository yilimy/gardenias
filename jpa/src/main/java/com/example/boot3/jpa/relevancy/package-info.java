/**
 * JPA一对一数据关联
 * <a href="https://www.bilibili.com/video/BV1vM4m1S7hT/" />
 * <p>
 *     在实际的开发中，个人并不建议大家去使用JPA的数据关联操作，包括后面要学习的Mybatis。
 *     单表的运行逻辑是最佳的，但是作为技术学习来讲，尤其是作为一本技术包含丰富的图书来讲，那肯定是要讲数据关联的。
 *     数据库之中存在有三种关联关系：
 *     -  一对一
 *     -  一对多
 *     -  多对多
 *     如果按照实际的表设计来讲，肯定是第三范式优先考虑，那么一对多是最常见的。
 * <p>
 *     其实现在的很多的项目开发里面，也不再设置表的关联操作（外键设计），尽量使用单表的方式进行处理，这样有助于后期的架构扩展。
 *     如果设计了这些关联的配置，容易给自己找事。
 * <p>
 *     一对一数据关联是数据表垂直拆分的一种技术手段。
 *     当某张表过多时，就可以考虑根据其数据的作用，拆分成不同的表进行存储。
 *     这样既保证了数据存储的性能，又保证提高了数据的安全性。e.g.
 *          在用户登录系统设计的结构中，可以创建一张Login的登录表，该表只保存有用户的登录ID和密码，
 *          而用户的详细信息可以保存在Detail详情表中。
 *          快速注册，多方式注册等，这个时候就存储的不是密码，而是设备MAC等。
 * <p>
 *     在使用JPA的时候，对于外键一定要进行配置（也就是不提倡使用数据关联结构开发JPA的原因，还是单表的映射结构会更好一些，关联关系在业务层进行有效的维护）
 *     实体类彼此之间需要使用特定的注解(@OneToOne)进行关联
 *     {@link com.example.boot3.jpa.po.Details}
 *     {@link com.example.boot3.jpa.po.Login}
 * <p>
 *     如果从更新的角度讲，只要处理好并发量，数据库的更新操作一般没有太大的问题。
 *     但是对于数据的查询来讲，在关联的结构之中就比较繁琐了。
 * <p>
 *     使用懒加载的抓取模式,当前关联结构里面所使用的数据抓取模式为 {@link jakarta.persistence.FetchType#EAGER},
 *     这个抓取操作就是一次性将全部所需要的关联数据全部抓取到位.
 *     但是现在可以对其进行修改, 更换抓取模式.
 * 一对多数据关联
 * <p>
 *     在进行数据库的设计中,需要依据数据库的设计范式,一对多的设计符合第三范式的要求.
 *     而在实际的开发过程中,第三范式也是最常见的,同样在JPA也支持一对多的数据关联结构.
 * <p>
 *     不推荐使用一对多的数据关联的原因
 *          原因一     JPA对一对多结构定义的严谨性,必须要有外键支持;
 *          原因二     性能问题
 *     {@link com.example.boot3.jpa.po.Dept}
 *     {@link com.example.boot3.jpa.po.Emp}
 * <p>
 *     懒加载的弊端:
 *          按照常规的业务层设计来说,每一次实现数据库查询之后,就应该进行数据库连接的释放.
 *          一旦数据库连接释放之后,这种懒加载操作就会出现问题.
 * <p>
 *     多对多
 *     <a href="https://www.bilibili.com/video/BV1F7421d7Ht/" />
 *     在一个用户权限管理系统中，多对多的结构是最常见的（Spring Security 设计里面也是最常见的）
 *     e.g.
 *     一个用户有多个权限（角色也是权限信息），常见的操作就是多对多的模型。
 *     Shiro涉及角色和权限，一个角色下会分为若干个权限
 *     {@link com.example.boot3.jpa.po.Member}
 *     {@link com.example.boot3.jpa.po.Role}
 *     注意：
 *          数据库有多对多的关联表 member_role，但是没有 member_role 的实体类
 *          由于 member_role 这个表中只有外键关联，因此该表交由 JPA 为维护，代码中提供对应的注解即可。
 *          如果外键关联表（member_role）中含有其他的数据项，则不能不能用多对多，而只能一对多。
 * @author caimeng
 * @date 2024/6/24 9:28
 */
package com.example.boot3.jpa.relevancy;